//1, 2, 3 더하기 (1) : 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
// 첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.
// 각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.

//dynamic programming 을 통해 답을 구하도록 한다 (피보나치 수열과 유사)

// 점화식의 원리
// 예를 들어, 15를 만들기 위해서는 다음과 같은 방법으로 만들 수 있습니다.

// 15 = (12를 만들기 위한 수많은 방법) + 3
// 15 = (13을 만들기 위한 수많은 방법) + 2
// 15 = (14를 만들기 위한 수많은 방법) + 1

// 이 방법들은 15를 만들기 위한 각각 서로 다른 방법이기 때문에,
// (15를 만드는 방법의 수) = (12를 만드는 방법의 수) + (13을 만드는 방법의 수) + (14를 만드는 방법의 수) 가 됩니다.

#include <cstdio>

int cal(int n){
    int arr [11] = {0};
    arr[1] = 1;
    arr[2] = 2;
    arr[3] = 4;
    if(n<4) return arr[n];
    for(int i=4; i<n+1; i++){
        arr[i] = arr[i-1] + arr[i-2] + arr[i-3];
    }
    return arr[n];
}

int main(){
    int n, input;
    scanf("%d", &n);
    while(n>0){
        scanf("%d", &input);
        printf("%d \n", cal(input));
        n--;
    }
}

// //master1511 
// int 자료형 선언에서 배열과 변수를 동시에 선언할 수 있음. 또한 입력값의 범위가 작으므로 그 값을 미리 모두 계산해놓은 다음 입력값에 따라 이미 계산해놓은 값을 출력하는 것이 매번 다시 계산하는 것보다 빠름 -> O(1)시간 안에 결과값을 가져올 수 있음 
// for 문의 두번째 조건(반복조건)으로 scanf("%d",&i)&&N--가 쓰였음을 보면 입력값이 있고 N값이 유효(0보다 큰 양수)할 때만 반복문이 실행될 것임을 알 수 있다. (좋은 technique으로 알아두자)

// int arr[13]={0,1,2,4},N,i; 
// int main(){
// 	for(i=4;i<=12;i++)arr[i]=arr[i-3]+arr[i-2]+arr[i-1];
// 	for(scanf("%d",&N);scanf("%d",&i)&&N--;)printf("%d\n",arr[i]);
//    return 0;
// }

// //oyu8201
// while 조건으로 t-- 변수를 직접 집어넣으면 0이 되는 순간 거짓이 되어 반복문이 종료되도록 한다 (좋은 technique인 듯)

// int t,a[11] = {1,1,2},n;
// int main() {
//     for (int i = 3; i <= 10; i++) a[i] = a[i - 1] + a[i - 2] + a[i - 3];
//     scanf("%d", &t);
//     while (t--) scanf("%d", &n), printf("%d\n", a[n]);
//     return 0;
// }